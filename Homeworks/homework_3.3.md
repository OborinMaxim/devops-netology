# Домашнее задание к занятию "3.3. Операционные системы. Лекция 1"

### Цель задания

В результате выполнения этого задания вы:

1. Познакомитесь с инструментом strace, который помогает отслеживать системные вызовы процессов, и является необходимым для отладки и расследований в случае возникновения ошибок в работе программ.
2. Рассмотрите различные режимы работы скриптов, настраиваемые командой set. Один и тот же код в скриптах в разных режимах работы ведет себя по-разному.

### Чеклист готовности к домашнему заданию

1. Убедитесь, что у вас установлен инструмент `strace`, выполнив команду `strace -V` для проверки версии. В Ubuntu 20.04 strace установлен, но в других дистрибутивах его может не быть "из коробки". Обратитесь к документации дистрибутива, как установить инструмент strace.
2. Убедитесь, что у вас установлен пакет `bpfcc-tools`, [сведения по установке](https://github.com/iovisor/bcc/blob/master/INSTALL.md)

### Инструменты/ дополнительные материалы, которые пригодятся для выполнения задания

1. Изучите документацию lsof - `man lsof` или та же информация, но в [сети](https://linux.die.net/man/8/lsof)
2. Документация по режимам работы bash находится в `help set` или в [сети](https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html)

------

## Задание

1. Какой системный вызов делает команда `cd`? 

    В прошлом ДЗ мы выяснили, что `cd` не является самостоятельной  программой, это `shell builtin`, поэтому запустить `strace` непосредственно на `cd` не получится. Тем не менее, вы можете запустить `strace` на `/bin/bash -c 'cd /tmp'`. В этом случае вы увидите полный список системных вызовов, которые делает сам `bash` при старте. 

    Вам нужно найти тот единственный, который относится именно к `cd`. Обратите внимание, что `strace` выдаёт результат своей работы в поток stderr, а не в stdout.

### Ответ
Системный вызов для команды `cd` называется `chdir`.

2. Попробуйте использовать команду `file` на объекты разных типов в файловой системе. Например:
    ```bash
    vagrant@netology1:~$ file /dev/tty
    /dev/tty: character special (5/0)
    vagrant@netology1:~$ file /dev/sda
    /dev/sda: block special (8/0)
    vagrant@netology1:~$ file /bin/bash
    /bin/bash: ELF 64-bit LSB shared object, x86-64
    ```
    Используя `strace` выясните, где находится база данных `file`, на основании которой она делает свои догадки.

### Ответ
База данных команды `file` находится по адресу: `/etc/magic`.

3. Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удален (deleted в lsof), однако возможности сигналом сказать приложению переоткрыть файлы или просто перезапустить приложение – нет. Так как приложение продолжает писать в удаленный файл, место на диске постепенно заканчивается. Основываясь на знаниях о перенаправлении потоков предложите способ обнуления открытого удаленного файла (чтобы освободить место на файловой системе).

### Ответ
Чтобы обнулить открытый удаленный файл, необходимо поток файлового дескриптора, который к нему обращается, перенаправить в `/dev/null` командой: `/proc/<PID>/fd/файловый_дескриптор > /dev/null`. Либо просто указать файловый дескриптор после символа перенаправления подобной командой: `> /proc/<PID>/fd/файловый_дескриптор`.

4. Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?

### Ответ
Зомби-процессы не занимают какие-либо ресурсы, т.к. они являются завершенными процессами и при этом лишь записями в таблице процессов, хранящей статус завершения, предназначенный для чтения родительским процессом.  
Однако, таким образом они блокируют записи в таблице процессов, размер которой ограничен для каждого пользователя и системы в целом. При достижении лимита записей все процессы пользователя, от имени которого выполняется создающий зомби родительский процесс, не будут способны создавать новые дочерние процессы. Кроме этого, пользователь, от имени которого выполняется родительский процесс, не сможет зайти на консоль (локальную или удаленную) или выполнить какие-либо команды на уже открытой консоли (потому что для этого командный интерпретатор должен создать новый процесс), и для восстановления работоспособности (завершения виновной программы) будет необходимо вмешательство системного администратора.

5. В iovisor BCC есть утилита `opensnoop`:
    ```bash
    root@vagrant:~# dpkg -L bpfcc-tools | grep sbin/opensnoop
    /usr/sbin/opensnoop-bpfcc
    ```
    На какие файлы вы увидели вызовы группы `open` за первую секунду работы утилиты? Воспользуйтесь пакетом `bpfcc-tools` для Ubuntu 20.04. Дополнительные [сведения по установке](https://github.com/iovisor/bcc/blob/master/INSTALL.md).

### Ответ
Вызовы группы `open` за первую секунду работы утилиты `opensnoop` на файлы: `/var/run/utmp`, `/usr/local/share/dbus-1/system-services`, `/usr/share/dbus-1/system-services`, `/lib/dbus-1/system-services`, `/var/lib/snapd/dbus-1/system-services/` (получено с помощью команды: `sudo opensnoop-bpfcc -d 1`).

6. Какой системный вызов использует `uname -a`? Приведите цитату из man по этому системному вызову, где описывается альтернативное местоположение в `/proc`, где можно узнать версию ядра и релиз ОС.

### Ответ
Команда `uname -a` использует системный вызов `uname`.  
Альтернативное местоположение в `/proc`, где можно узнать версию ядра и релиз ОС: Part of the utsname information is also accessible via `/proc/sys/kernel/{ostype, hostname, osrelease, version, domainname}`.

7. Чем отличается последовательность команд через `;` и через `&&` в bash? Например:
    ```bash
    root@netology1:~# test -d /tmp/some_dir; echo Hi
    Hi
    root@netology1:~# test -d /tmp/some_dir && echo Hi
    root@netology1:~#
    ```
    Есть ли смысл использовать в bash `&&`, если применить `set -e`?

### Ответ
Спец. символ `;` применяется для выполнения нескольких команд одна за другой, независимо от успеха выполнения предыдущей. При использовании же спец. символа `&&` вторая команда выполняется при удачном завершении первой.  
При выполнении `set -e` оболочка также завершает работу, когда какая-либо команда в списке команд завершается ненулевым значением.

8. Из каких опций состоит режим bash `set -euxo pipefail` и почему его хорошо было бы использовать в сценариях?

### Ответ
`set -euxo pipefail` состоит из опций:  
`-e` - немедленно прекращает выполнение сценария, если какая-либо команда завершилась ошибкой;  
`-u` - прекращает выполнение сценария, если встретилась несуществующая переменная;  
`-x` - выводит выполняемые команды в stdout перед выполнением;  
`-o pipefail` - при использовании в сценарии конвейера, вернёт ноль, если все команды в конвейере завершились удачно, или код первой из команд, вернувшей не ноль (по умолчанию код возврата конвейера равен коду возврата последней команды).  
Все это помогает делать более безопасные сценарии и выявлять ошибки, при их возникновении.

9. Используя `-o stat` для `ps`, определите, какой наиболее часто встречающийся статус у процессов в системе. В `man ps` ознакомьтесь (`/PROCESS STATE CODES`) что значат дополнительные к основной заглавной буквы статуса процессов. Его можно не учитывать при расчете (считать S, Ss или Ssl равнозначными).

### Ответ
Статусы у процессов при выводе команды `ps -o stat`: `Ss` и `R+` (по одному процессу).  
Наиболее часто встречающийся статус у всех процессов в системе (при выводе команды `ps -Ao stat`) - `S`.  
Согласно `man ps`:  
`S` - прерываемый сон  
`R` - выполняется или ожидает выполнения  
дополнительные символы:  
`<` - высокоприоритетный  
`N` - с низким приоритетом  
`L` - имеет страницы, заблокированные в памяти  
`s` - является лидером сессии  
`l` - является многопоточным  
`+` - находится в группе процессов переднего плана

----

### Правила приема домашнего задания

В личном кабинете отправлена ссылка на .md файл в вашем репозитории.


### Критерии оценки

Зачет - выполнены все задания, ответы даны в развернутой форме, приложены соответствующие скриншоты и файлы проекта, в выполненных заданиях нет противоречий и нарушения логики.

На доработку - задание выполнено частично или не выполнено, в логике выполнения заданий есть противоречия, существенные недостатки. 