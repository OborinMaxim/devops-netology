# Домашнее задание к занятию "6.6. Troubleshooting"

## Задача 1

Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её 
нужно прервать. 

Вы как инженер поддержки решили произвести данную операцию:
- напишите список операций, которые вы будете производить для остановки запроса пользователя
- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

### Ответ
Вычислить запрос можно с помощью команды `db.currentOp({"secs_running": {$gte: 180}})`. В выводе в поле *query* увидим запрос. Прервать операцию можно с помощью `db.killOp(<opId>)`.  
Выяснить причину долгих запросов поможет метод *.explain("executionStats")*. В зависимости от причины, решение проблемы может быть разным. Как вариант - провести индексацию базы данных.

## Задача 2

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и
увеличивается пропорционально количеству реплик сервиса. 

При масштабировании сервиса до N реплик вы увидели, что:
- сначала рост отношения записанных значений к истекшим
- Redis блокирует операции записи

Как вы думаете, в чем может быть проблема?

### Ответ
Механизм активного удаления ключей с истекшим сроком действия в Redis запускается каждые 100 миллисекунд (10 раз в секунду), удаляет выявленные ключи с истекшим сроком (по умолчанию 20), а если более 25% ключей оказываются просроченными - повторяет операцию. Таким образом, если в базе большое количество ключей, срок действия которых истекает в одну и ту же секунду, и они составляют не менее 25% текущей совокупности ключей с установленным сроком действия, Redis может заблокировать операции записи, чтобы опустить процент ключей, срок действия которых уже истек, ниже 25%. Этот подход используется, чтобы не использовать слишком много памяти для ключей с истекшим сроком действия.
 
## Задача 3

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему?

Какие пути решения данной проблемы вы можете предложить?

### Ответ
Эта ошибка появляется, когда время ожидания соединения между клиентом MySQL и сервером базы данных истекает. Запрос возвращает данные слишком долго, поэтому соединение разрывается.  
Обычно эта ошибка указывает на проблемы с подключением к сети, поэтому во-первых следует проверить состояние сети, если ошибка возникает часто.  
Иногда такое возникает, когда миллионы строк отправляются как часть одного или нескольких запросов. Если это так, следует попробовать увеличить значение *net_read_timeout* с 30 секунд по умолчанию до 60 секунд или более, чтобы было достаточно для завершения передачи данных.  
Реже это может произойти, когда клиент пытается установить первоначальное соединение с сервером. В этом случае, если значение *connect_timeout* установлено всего на несколько секунд, можно решить проблему, увеличив его до 10 секунд или более, если расстояние довольно большое или скорость соединения достаточно медленная. Можно определить, это ли является причиной ошибки, используя *SHOW GLOBAL STATUS LIKE 'Aborted_connects'*. Он увеличивается на единицу за каждую первоначальную попытку подключения, которую прерывает сервер.

## Задача 4

Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?

Как бы вы решили данную проблему?

### Ответ
Out-Of-Memory Killer - это процесс Linux, который в случае нехватки памяти в системе, завершает какое-либо приложение, потребляющее память, чтобы спасти ядро от сбоя. Он жертвует приложением, чтобы сохранить работу ОС.  
Соответственно, в указанном случае, процесс PostgreSQL с точки зрения Linux является наиболее подходящим для остановки и спасения системы от аварийного завершения.  
Варианта решения проблемы два. Первый - увеличить количество общей памяти в системе. Второй - установить для *vm.overcommit_memory* значение 2.  
Переменная *vm.overcommit_memory* отвечает за поведение Linux в части резервирования и выделения процессам памяти. При установленном значении 2, ядро не будет резервировать больше памяти, чем указано в параметре *overcommit_ratio*. В этом параметре указывается процент памяти, для которого допустимо избыточное резервирование. Если для него нет места, память не выделяется, в резервировании будет отказано. Это не будет гарантировать, что OOM-Killer не придется вмешиваться, но снизит вероятность принудительного завершения процесса PostgreSQL.

---

### Как cдавать задание

Выполненное домашнее задание пришлите ссылкой на .md-файл в вашем репозитории.

---